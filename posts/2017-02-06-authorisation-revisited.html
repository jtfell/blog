<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Julian Fell - Authorisation Revisited</title>
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <link rel="stylesheet" type="text/css" href="../css/base.css" />
        <link rel="stylesheet" type="text/css" href="../css/pandoc.css" />
        <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700|Roboto:400,700" rel="stylesheet" />
    </head>
    <body>
      <header class="mx-auto px3 py4">
        <a class="h0 mb0 bold black text-decoration-none" href="https://jtfell.github.io">Julian Fell</a>
      </header>

      <section class="mx-auto px3 py3 e-content">
        <h2 class="h2 caps">Authorisation Revisited</h2>
        <div><p>With the emergence of any new programming paradigm, there are opportunities to take a fresh approach to old problems. Well established best-practices can be improved upon with new tools and more information available to the engaged developer.</p>
<p>The rise of REST APIs has been well documented, and as a consequence,their authorisation has been given plenty of thought by some pretty smart people. The big players have undoubtedly built bullet-proof authorisation strategies to protect their services and users, but that’s not to say there aren’t ways to do it better.</p>
<p>I have recently been building out my first GraphQL API using NodeJS and while there is plenty of discussion on authentication methods, I struggled to find any in-depth consideration of what to do once the user is authenticated. The way I see it, there are some amazing new opportunities to take advantage of in this space just waiting to be mined.</p>
<p>As I began to understand the high level structure of a GraphQL server, I wonder how to avoid making a separate database request for every field in the schema. I was not alone in this. I came across the brilliant <a href="https://github.com/facebook/dataloader">dataloader</a> library from Facebook and the way forward became clear. The genius at the heart of dataloader is in how it leverages the structure of the resolver functions. It unlocks improved performance through batching and cacheing database requests with hardly any abstraction overhead.</p>
<p>I know cacheing your database requests isn’t something people get excited about in 2017, but this hints at an important point. Changes to the established paradigm can usher in new innovations in unexpected ways. Obviously GraphQL is a huge deal for self-documentation, client/server decoupling and type safety, but that is just the beginning. There are huge shifts in request heuristics, opportunities for pre- analysing the query before deciding on an optimisation strategy and many other critical changes for the average API server.</p>
<p>So let’s get to leveraging some of them for solving the problem of authorisation. For starters, GraphQL queries will generally be larger and less frequent (per client) than their REST counterpart. This allows us to optimise some of the heavy lifting up front and build up an easy-to-access cache of the users permissions at the start of the request. After this initial database hit, the individual authorisation checks can be completed extremely quickly rather than having to visit the database for each check. This optimisation is unlocked by the client sending a single arbitrarily nested query rather than hitting a number of different endpoints to cobble together the data required for their UI or action. Add the ability to pre- nalyse the query for complexity (or even which parts of the schema are touched) and you can have multiple optimisation strategies to gain maximum performance for queries of any size and nature.</p>
<p>If you will excuse the shameless plug (you knew it was coming), my new library <a href="https://github.com/jtfell/authorizr">authorizr</a> attempts to enable some of these optimisations. It’s in use on the new GraphQL project I’m working on and has been a revelation in abstracting away the nitty gritty of permissions tables etc and exposing a simple API.</p>
<p>This in turn makes the resolver functions easy to reason about. There are some similarities with the philosophy of dataloader and for this reason the two libraries play well together. But as with any new development, there are always going to be new problems to solve.</p>
<p>The biggest killer of dreams so far has been the need for fresh data. Much like with dataloader needing a loader.clear method to allow stale data to be flushed from the cache, authorizr needs to be able to react to changes in permissions and data. The best approach for this is less clear for an authorisation mechanism with no constraints on the structure of application data than for a cacheing mechanism. Finding a clean way of going about this is yet to materialise for me but maybe someone smarter than me will have a game changing idea and submit a PR for it (hint, hint).</p>
<p>Unsolved problems aside, there is much to be excited about in the GraphQL server space!</p></div>

<section>
	<h2>Webmentions</h2>
	<div id="webmentions"></div>
</section>

<a href="https://brid.gy/publish/twitter"></a>

<script>
const container = document.querySelector("#webmentions");

if (container) {
  renderWebmentions(container);
}

async function renderWebmentions(container) {
  const webmentions = await getWebmentions(window.location.href);

  if (webmentions.length === 0) {
    return;
  }

  const list = document.createElement("ul");
  list.className = "webmentions";

  webmentions.forEach(webmention => {
    list.appendChild(renderWebmention(webmention));
  });

  container.appendChild(list);
}

function getWebmentions(target) {
  console.log(target, window.location);
  return fetch('https://webmention.io/api/mentions.jf2?target=' + target)
    .then(response => response.json())
    .then(data => data.children);
}

function renderWebmention(webmention) {
  const action = {
    "in-reply-to": "replied",
    "like-of": "liked",
    "repost-of": "reposted",
    "mention-of": "mentioned"
  }[webmention["wm-property"]];

  const rendered = document.importNode(
    document.getElementById("webmention-template").content,
    true
  );

  function set(selector, attribute, value) {
    rendered.querySelector(selector)[attribute] = value;
  }

  set(".webmention-author", "href", webmention.author.url || webmention.url);
  set(".webmention-author-avatar", "src", webmention.author.photo);
  set(".webmention-author-avatar", "alt", `Photo of 
      </section>

      <footer class="flex items-baseline max-width-4 mx-auto px3 py4">
          <a href="/index.html" class="h6 bold caps black">Blog Home</a>
      </footer>
    </body>

    <style>

      /* Lazy hacks for bad behaving elements */
      .text-decoration-none:hover {
        background-image: none;
      }

      img {
        max-width: 100%;
      }

      header {
        padding-bottom: 0px !important;
      }
    </style>
</html>


