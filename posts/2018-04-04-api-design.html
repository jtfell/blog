<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Julian Fell - API Design for Pragmatists</title>
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <link rel="stylesheet" type="text/css" href="../css/base.css" />
        <link rel="stylesheet" type="text/css" href="../css/pandoc.css" />
        <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700|Roboto:400,700" rel="stylesheet" />
    </head>
    <body>
      <header class="mx-auto px3 py4">
        <a class="h0 mb0 bold black text-decoration-none" href="https://jtfell.github.io">Julian Fell</a>
      </header>

      <section class="mx-auto px3 py3 h-entry">
        <h2 class="h2 caps p-name">API Design for Pragmatists</h2>
        <span>
          <div class="e-content"><p>Over the course of a few years building web apps, I’ve come across (and built) some subpar REST APIs. There are plenty of surefire ways to design an API that will cause headaches for users and maintainers alike so it is in everyone’s best interest to lend a hand. Consider this list an investment in the welbeing of the internet at large.</p>
<h3 id="explicit-date-and-time-handling">Explicit date and time handling</h3>
<p>Dates and timezones have caused the most bugs of anything in my experience of API design. Whoever decided how modern timezones work has a lot to answer for and you don’t want to make the situation any worse. Make sure that all dates are validated and only accept a pre-defined set of date formats (I suggest ISO formats with explicit timezones) so that there is no ambiguity about what timezone you are dealing with. Don’t forget that browsers default to using local times in many situations, so forgetting to send a timezone will result in the API interpretting the time incorrectly.</p>
<h3 id="json-schema-validation-for-all-postputs">JSON Schema validation for all POST/PUTs</h3>
<p>JSON schema is the perfect solution for protecting yourself from trash data. Taking the time to properly define the expected structure of inputs will pay dividends almost immediately as your controllers no longer have to be written defensively. From useful error messages to documentation generation, the benefits are huge and there are validation libraries for all mainstream languages. Just do this one. You can even take this a step further and generate the code for your controllers based off these definitions. Also consider adopting the <a href="http://jsonapi.org/">JSON API</a> standard as there are lots of tools for generating response structures and validating their consistency.</p>
<h3 id="most-granularlocked-down-db-schema-possible">Most granular/locked down DB schema possible</h3>
<p>I won’t hesitate to admit I’m a traditionalist when it comes to databases. The consistency and data integrity you can achieve purely through a strict SQL schema will ALWAYS be worth the initial effort of defining it. My advice is to explicitly encode every property, relationship and restriction into your schema as this will make the database reject invalid data and also give engineers a single place to go to understand your data model.</p>
<h3 id="use-well-understood-persistence-tech-postgres-redis-unless-demonstrated-need-for-specific-featuresperformance">Use well-understood persistence tech (postgres / redis) unless demonstrated need for specific features/performance</h3>
<p>Closely related to the previous point, I would always recommend using a well-understood database. A single Postgres instance can scale a pretty long way if you don’t write pathological queries and will be straightforward operationally. Think about how easy it is it backup, restore from failure, debug errors and investigate performance issues when the internet is full of experts who have already seen your exact problem before.</p>
<h3 id="prefixed-logging">Prefixed logging</h3>
<p>Logging can be difficult to get right as you need to find a balance between filling your logs with garbage and missing out critical data for debugging. My advice is to prefix the logs with information about the service or model that they correspond to. This will allow you to err on the side of too much logging and still allow you to find the data you are looking for.</p>
<h3 id="consider-pagination-early">Consider pagination early</h3>
<p>Maybe this one is an obvious one but it is worth mentioning as I’ve been bitten by this more times than I’d like to admit. If an endpoint returns a list of something, you WILL need pagination at some point (unless its a fixed list). To avoid a breaking change later on, always return a length field (the number of results in the full set) and return a reasonable number of results by default along with optional pagination controls.</p>
<h3 id="dont-be-too-cute-with-deletes">Don’t be too cute with deletes</h3>
<p>It is very common advice to flip a <code>deleted</code> or <code>archived</code> flag on database entries when they are deleted, rather than actually deleting the row. I get why this is seems like a good idea; you can restore any accidentally deleted records as easily as they are deleted because nothing is ever actually deleted. Okay sure, that is a useful property, but let’s think about the consequences of this choice. Everytime you want to interact with that table, you now have to check that field to see if it is still meant to exist! My advice is to copy deleted data to a second table and then actually delete it from the main one. This requires a little data juggling for delete operations but will greatly simplify the rest of your app.</p>
<h3 id="careful-with-pii">Careful with PII</h3>
<p>This is particularly topical at the moment with GDPR coming into effect and a number of high-profile data breaches dominating the tech headlines. Whenever collecting personal information from users, stop and ask yourself whether you really need it! If you don’t absolutely need it for your core business then it’s probably not worth the hassle. If you definitely need it, go and read <a href="https://gdpr-info.eu/">this</a>. Then read it again. Then finally design your handling of that data to be compliant from the outset, with the ability for users to fully delete themselves from your system in your very first release.</p>
<h3 id="take-devops-seriously">Take devops seriously</h3>
<p>How long has it been since you tried restoring your system from a database or deployment failure? If you are embarressed by your answer then it’s not too late! Carve out some time for making sure your deployments are replicable (infrastructure as code is helpful here) and that you have an up-to-date strategy for restoring from your latest database backup (you have backups right?).</p>
<h3 id="standardised-error-messages-with-codes">Standardised error messages with codes</h3>
<p>Consumers of your API will thank you a million times over if you send back useful error messages for incorrect usage. Just including a unique error code (with a reference in your public docs) is a great start.</p></div>

<section id="webmention-container">
	<h2>Webmentions</h2>
	<div id="webmentions"></div>
</section>

<footer class="flex items-baseline max-width-4 mx-auto px3 py4">
    <a class="u-url h6 bold caps black justify-around" href="../posts/2018-04-04-api-design.html">
      Published <time class="dt-published">April  4, 2018</time>
    </a> 
    <div class="justify-around">//</div>
    <a href="../" class="h6 bold caps black justify-around">Blog Home</a>
</footer>

<a href="https://brid.gy/publish/twitter"></a>

<script>
const container = document.querySelector("#webmentions");

if (container) {
  renderWebmentions(container);
}

async function renderWebmentions(container) {
  const webmentions = await getWebmentions(window.location.href);

  // Hide the webmentions section if there aren't any of them to show
  if (webmentions.length === 0) {
    const section = document.getElementById("webmention-container");
    section.style.display = 'none';
    return;
  }

  const list = document.createElement("ul");
  list.className = "webmentions";

  webmentions.forEach(webmention => {
    list.appendChild(renderWebmention(webmention));
  });

  container.appendChild(list);
}

function getWebmentions(target) {
  return fetch('https://webmention.io/api/mentions.jf2?target=' + target)
    .then(response => response.json())
    .then(data => data.children);
}

function renderWebmention(webmention) {
  const action = {
    "in-reply-to": "replied",
    "like-of": "liked",
    "repost-of": "reposted",
    "mention-of": "mentioned"
  }[webmention["wm-property"]];

  const rendered = document.importNode(
    document.getElementById("webmention-template").content,
    true
  );

  function set(selector, attribute, value) {
    rendered.querySelector(selector)[attribute] = value;
  }

  set(".webmention-author", "href", webmention.author.url || webmention.url);
  set(".webmention-author-avatar", "src", webmention.author.photo);
  set(".webmention-author-avatar", "alt", 'Photo of ' + webmention.author.name);
  set(".webmention-author-name", "textContent", webmention.author.name);
  set(".webmention-action", "href", webmention.url);

  set(
    ".webmention-action",
    "textContent",
    action + ' on ' + webmention["wm-received"].substr(0, 10)
  );

  if (webmention.content) {
    set(
      ".webmention-content",
      "innerHTML",
      webmention.content.html || webmention.content.text
    );
  }

  return rendered;
}
</script>

        </span>
      </section>
    </body>

    <style>

      /* Lazy hacks for bad behaving elements */
      .text-decoration-none:hover {
        background-image: none;
      }

      img {
        max-width: 100%;
      }

      header {
        padding-bottom: 0px !important;
      }
    </style>
</html>


