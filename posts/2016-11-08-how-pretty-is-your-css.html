<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Julian Fell - How Pretty Is Your CSS?</title>
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <link rel="stylesheet" type="text/css" href="../css/base.css" />
        <link rel="stylesheet" type="text/css" href="../css/pandoc.css" />
        <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700|Roboto:400,700" rel="stylesheet" />
    </head>
    <body>
      <header class="mx-auto px3 py4">
        <a class="h0 mb0 bold black text-decoration-none" href="https://jtfell.github.io">Julian Fell</a>
      </header>

      <section class="mx-auto px3 py3">
        <h2 class="h2 caps">How Pretty Is Your CSS?</h2>
        <div><p>There are already a few apps out there that analyse stylesheets (my favourite is <a href="http://cssstats.com">cssstats</a>), but they’re focused on how well structured the code is. Sure it’s nice to know how maintainable your CSS is, but I want more; I want to know how pretty it will make my page. I mean, thats the end game isn’t it?</p>
<p>The aesthetic quality of a page is governed by mathematical rules. These rules can be harnessed to improve your page layouts even if you have minimal design experience or intuition (me). I’m proposing that we try to compare how well certain CSS frameworks adhere to some of the basic rules of design. Of course, there are far too many subtleties in how CSS declarations make a page look and feel to confidently say one layout is better than another based off some arbitrary metrics, but I’m down for a challenge and the insights it will bring.</p>
<p>To pick a one rule out of a sea of options, let’s tackle validating modular scales (every font size on a page should be related by a single ratio). Let’s decide on a scope up front to keep this achievable.</p>
<ul>
<li>Only analyse plain CSS (no SASS or LESS)</li>
<li>Values using em units aren’t nested (so they behave the same as rem)</li>
<li>All declarations are in use</li>
</ul>
<p>From this we will calculate:</p>
<ul>
<li>Whether the font-size declarations use a modular scale</li>
<li>What the ratio is (if it exists)</li>
</ul>
<h3 id="working-backwards">Working Backwards</h3>
<p>Over at <a href="http://type-scale.com">type-scale.com</a> you can pick a base and ratio, and get back a nice little CSS snippet. This will do nicely as a test-case to see if we can work backwards to the values used as an input. I fired it up with a base size of 1em and ratio of 1.5 to keep things simple and got this little snippet back.</p>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css">html <span class="kw">{font-size:</span> <span class="dt">1em</span><span class="kw">;}</span>

body <span class="kw">{</span>
  <span class="kw">background-color:</span> <span class="dt">white</span><span class="kw">;</span>
  <span class="kw">font-family:</span> <span class="st">'Roboto'</span>, <span class="dt">serif</span><span class="kw">;</span>
  <span class="kw">font-weight:</span> <span class="dt">600</span><span class="kw">;</span>
  <span class="kw">line-height:</span> <span class="dt">1.45</span><span class="kw">;</span>
  <span class="kw">color:</span> <span class="dt">#333</span><span class="kw">;</span>
<span class="kw">}</span>

p <span class="kw">{margin-bottom:</span> <span class="dt">1.3em</span><span class="kw">;}</span>

h1, h2, h3, h4 <span class="kw">{</span>
  <span class="kw">margin:</span> <span class="dt">1.414em</span> <span class="dt">0</span> <span class="dt">0.5em</span><span class="kw">;</span>
  <span class="kw">font-weight:</span> <span class="dt">inherit</span><span class="kw">;</span>
  <span class="kw">line-height:</span> <span class="dt">1.2</span><span class="kw">;</span>
<span class="kw">}</span>

h1 <span class="kw">{</span>
  <span class="kw">margin-top:</span> <span class="dt">0</span><span class="kw">;</span>
  <span class="kw">font-size:</span> <span class="dt">5.063em</span><span class="kw">;</span>
<span class="kw">}</span>

h2 <span class="kw">{font-size:</span> <span class="dt">3.375em</span><span class="kw">;}</span>

h3 <span class="kw">{font-size:</span> <span class="dt">2.25em</span><span class="kw">;}</span>

h4 <span class="kw">{font-size:</span> <span class="dt">1.5em</span><span class="kw">;}</span>

small, <span class="fl">.font_small</span> <span class="kw">{font-size:</span> <span class="dt">0.667em</span><span class="kw">;}</span></code></pre></div>
<h3 id="sketching-a-solution">Sketching A Solution</h3>
<p>Ok, down to business. I’m going to use PostCSS because it’s trendy and because the AST it exposes will make getting at the declarations nice and easy (but mainly because it’s trendy). Let’s install it.</p>
<p><code>npm i postcss --save</code></p>
<p>Okay, now we’re set up and need a skeleton for doing the analysis.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> postcss <span class="op">=</span> <span class="at">require</span>(<span class="st">'postcss'</span>)<span class="op">;</span>

<span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> <span class="kw">function</span>(css) <span class="op">{</span>
  <span class="kw">var</span> root <span class="op">=</span> <span class="va">postcss</span>.<span class="at">parse</span>(css)<span class="op">;</span>

  <span class="co">// 1. Parse the AST and collect all font-size declarations</span>
  <span class="kw">var</span> properties <span class="op">=</span> <span class="at">findFontSizeDecl</span>(root)<span class="op">;</span>

  <span class="co">// 2. Calculate the ratio used and the quality of the fit</span>
  <span class="kw">var</span> results <span class="op">=</span> <span class="at">calculateRatio</span>(properties)<span class="op">;</span>
  
  <span class="va">console</span>.<span class="at">log</span>(results)<span class="op">;</span>
<span class="op">};</span></code></pre></div>
<p>Note the two major steps to be filled in, <code>findFontSizeDecl</code> and <code>calculateRatio</code>. Let’s kick it off with step 1. We’re just pulling out all the <code>font-size</code> declarations out of the CSS and making a list of relative values. I’ve made some serious simplifications here as calculating the pixel height of em is way out of the scope of this experiment.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">findFontSizeDecl</span>(root) <span class="op">{</span>
  <span class="kw">var</span> vals <span class="op">=</span> []<span class="op">;</span>

  <span class="co">// Iterate over font-size declarations</span>
  <span class="va">root</span>.<span class="at">walkDecls</span>(<span class="ss">/font-size/</span><span class="op">,</span> <span class="kw">function</span>(decl) <span class="op">{</span>
    <span class="va">vals</span>.<span class="at">push</span>(<span class="at">convertToEm</span>(<span class="va">decl</span>.<span class="at">value</span>))<span class="op">;</span>
  <span class="op">}</span>)<span class="op">;</span>

  <span class="cf">return</span> vals<span class="op">;</span>
<span class="op">};</span>

<span class="kw">var</span> ROOT_FONT_SIZE <span class="op">=</span> <span class="dv">16</span><span class="op">;</span>
<span class="kw">function</span> <span class="at">convertToEm</span>(value) <span class="op">{</span>
  <span class="cf">if</span> (value <span class="op">==</span> <span class="dv">0</span>) <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span>
  <span class="cf">if</span> (<span class="va">value</span>.<span class="at">indexOf</span>(<span class="st">'rem'</span>) <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">{</span>
    <span class="cf">return</span> <span class="at">parseFloat</span>(<span class="va">value</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">3</span>))<span class="op">;</span>
  <span class="op">}</span>
  <span class="cf">if</span> (<span class="va">value</span>.<span class="at">indexOf</span>(<span class="st">'em'</span>) <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">{</span>
    <span class="cf">return</span> <span class="at">parseFloat</span>(<span class="va">value</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">2</span>))<span class="op">;</span>
  <span class="op">}</span>
  <span class="cf">if</span> (<span class="va">value</span>.<span class="at">indexOf</span>(<span class="st">'px'</span>) <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">{</span>
    <span class="kw">var</span> pixels <span class="op">=</span> <span class="at">parseFloat</span>(<span class="va">value</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">2</span>))<span class="op">;</span>
    <span class="cf">return</span> pixels/ROOT_FONT_SIZE<span class="op">;</span>
  <span class="op">}</span>
  <span class="co">// Skip declarations of inherits, initial</span>
  <span class="va">console</span>.<span class="at">log</span>(<span class="st">'Skipping: '</span><span class="op">,</span> value)<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>No sweat, on to Step 2. As we are assuming that the font-sizes will have a constant ratio, we can use exponential regression. The algorithm for this is all over the internet so I won’t bore you with it, but the code I’m using is here. Applying the algorithm is very straightforward.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">calculateRatio</span>(xs) <span class="op">{</span>
  <span class="kw">var</span> uniqueSizes <span class="op">=</span> <span class="va">xs</span>.<span class="at">sort</span>().<span class="at">filter</span>(onlyUnique)<span class="op">;</span>
  <span class="cf">return</span> <span class="at">exponentialRegression</span>(uniqueSizes)<span class="op">;</span>
<span class="op">}</span>

<span class="kw">function</span> <span class="at">onlyUnique</span>(value<span class="op">,</span> index<span class="op">,</span> self) <span class="op">{</span>
  <span class="cf">return</span> <span class="va">self</span>.<span class="at">indexOf</span>(value) <span class="op">===</span> index<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>Now the core of the analysis is ready to go, all we need is to set up a test harness.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">'fs'</span>)<span class="op">;</span>
<span class="kw">var</span> analyse <span class="op">=</span> <span class="at">require</span>(<span class="st">'../src/index.js'</span>)<span class="op">;</span>

<span class="kw">var</span> css <span class="op">=</span> <span class="va">fs</span>.<span class="at">readFileSync</span>(<span class="st">'./test/basic.css'</span><span class="op">,</span> <span class="st">'utf8'</span>)<span class="op">;</span>
<span class="at">analyse</span>(css)<span class="op">;</span>

<span class="co">// Prints:</span>
<span class="co">// { ratio: 1.4999140493583407, fit: 0.9999999752384222 }</span></code></pre></div>
<p>As promised, we get back the ratio we started with and a “fit” value close to one. So far, so good.</p>
<h3 id="showdown">Showdown</h3>
<p>The true test will be analysing some real CSS frameworks.</p>
<pre><code>Basscss:    ratio: 1.212, fit: 0.9921
Foundation: ratio: 1.097, fit: 0.9821
Bootstrap:  ratio: 1.121, fit: 0.9653
Pure:       ratio: 1.360, fit: 0.9170</code></pre>
<p>Does this mean that Foundation is better than Bootstrap? You be the judge. It would be a little hasty to draw too many conclusions from these results without looking deeper into why certain frameworks do not strictly follow modular scales. Undoubtedly there are good reasons, edge cases or stylistic preferences. All I know is that I want to know what these are if I’m going to commit to them for a new project. If nothing else, finding answers to these questions might lend some insight into how to get the most out of your framework of choice.</p>
<p>That’s all I have for now, you can take a look at my code <a href="https://github.com/jtfell/style-analytics">here</a>.</p></div>

      </section>

      <footer class="flex items-baseline max-width-4 mx-auto px3 py4">
          <a href="../index.html" class="h6 bold caps black">Blog Home</a>
      </footer>
    </body>

    <style>

      /* Lazy hacks for bad behaving elements */
      .text-decoration-none:hover {
        background-image: none;
      }

      img {
        max-width: 100%;
      }

      header {
        padding-bottom: 0px !important;
      }
    </style>
</html>


