<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Julian Fell - Garbage Collector Low-Level API</title>
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <link rel="stylesheet" type="text/css" href="../css/base.css" />
        <link rel="stylesheet" type="text/css" href="../css/pandoc.css" />
        <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700|Roboto:400,700" rel="stylesheet" />
    </head>
    <body>
      <header class="mx-auto px3 py4">
        <a class="h0 mb0 bold black text-decoration-none" href="https://jtfell.github.io">Julian Fell</a>
      </header>

      <section class="mx-auto px3 py3">
        <h2 class="h2 caps">Garbage Collector Low-Level API</h2>
        <div><p>See this <a href="./2018-01-23-garbage-collector.markdown">Previous Post</a> for the design of my uber simple garbage collector. I’m spliting the initial implementation into 2 phases, the low-level block-based memory allocation API and the higher-level API for allocating runtime objects and cleaning them back up. This article will focus on building the low-level bit that will be built upon for more useful abstractions.</p>
<h3 id="jump-in-the-pool">Jump in the pool</h3>
<p>First up, we need to prepare the memory pool and set up some book keeping globals (yeah I know, bad style but I’m just doing this for learning so get off your high horse). Please don’t see these code examples and use them in your project, I haven’t written any C since I finished my university degree 2 years ago so am likely commiting plenty of sins in the process of sketching out this GC prototype.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#define BLOCK_SIZE 1024</span>

<span class="co">// Direct pointers to memory locations</span>
<span class="dt">void</span> * mappingStartLocation;
<span class="dt">void</span> * mappingCurrentLocation;
<span class="dt">void</span> * allocStartLocation;
<span class="dt">void</span> * allocCurrentLocation;
<span class="dt">void</span> * allocEndLocation;

<span class="dt">void</span> gc_pool_init() {

  <span class="co">// Allocate space for management struct</span>
  mappingStartLocation = sbrk(<span class="dv">0</span>);
  sbrk(<span class="dv">50</span> * <span class="kw">sizeof</span>(bdescr));

  <span class="co">// Get the start address</span>
  allocStartLocation = sbrk(<span class="dv">0</span>);

  <span class="co">// Allocate a chunk of memory</span>
  sbrk(<span class="dv">50</span> * BLOCK_SIZE);

  <span class="co">// Get the final address</span>
  allocEndLocation = sbrk(<span class="dv">0</span>);

  mappingCurrentLocation = mappingStartLocation;
  allocCurrentLocation = allocStartLocation;
}</code></pre></div>
<p>The <code>sbrk</code> system call will both return the current memory address and allocate more memory if you pass in an argument that is greater than 0. This initialisation code basically allocates a chunk of memory for keeping bookkeeping info in and a larger chunk of memory for allocating to blocks. As it does this it keeps track of a bunch of pointers that reference key locations in the heap.</p>
<h3 id="allocation">Allocation</h3>
<p>Next up we need to be able to allocate groups of blocks of memory on our heap.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">bdescr * alloc_group(<span class="dt">int</span> n) {
  bdescr * blk;

  <span class="co">// Keep a reference to the first block we're allocating</span>
  bdescr * firstBlk = (bdescr *) mappingCurrentLocation;
  bdescr * prevBlk = firstBlk;

  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {

    <span class="co">// Create a mapping entry</span>
    blk = (bdescr *) mappingCurrentLocation;
    mappingCurrentLocation += <span class="kw">sizeof</span>(bdescr);

    blk-&gt;allocated = true;

    <span class="co">// Point to the next free block of unallocated space</span>
    blk-&gt;start = allocCurrentLocation;
    allocCurrentLocation += BLOCK_SIZE;

    <span class="co">// If not the first block in the group, link the previous one to this block</span>
    <span class="cf">if</span> (mappingCurrentLocation != prevBlk) {
      prevBlk-&gt;link = blk;
    } <span class="cf">else</span> {
      prevBlk-&gt;link = NULL;
    }

    prevBlk = blk;
  }

  <span class="cf">return</span> firstBlk;
}</code></pre></div>
<p>No huge surprises there I should think. We loop from 0 up to the number of blocks that are to be in the group and flag these blocks as allocated, move the bookkeeping pointers along and link each block to the next one. It’s important to note that the final block in a group will have a <code>NULL</code> pointer instead of a link to the next block.</p>
<h3 id="freedom-for-all">Freedom for all</h3>
<p>We’re on the home stretch now, just freeing a group left. All we need to do is follow the chain of links and flick the allocated flag to false.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> free_group(bdescr *p) {
  bdescr * blk = p;

  <span class="cf">while</span>(blk-&gt;link != NULL) {
    blk-&gt;allocated = false;
    blk = blk-&gt;link;
  }
  blk-&gt;allocated = false;
}</code></pre></div>
<p>One simplifaction I’ve used throughout all of this code is that the allocation only goes upwards, never looking back at previously allocated groups. This is because I plan on using a garbage collection algorithm which moves all memory that is still in use to a fresh heap each time, allowing the allocation to start over at the new high-water mark and grow all over again.</p>
<p>You can see the rest of the implementation including some debugging functions that print out the state <a href="https://github.com/jtfell/compiler-llvm/blob/master/lib/gc/lib.c">here</a>.</p></div>

      </section>

      <footer class="flex items-baseline max-width-4 mx-auto px3 py4">
          <a href="../index.html" class="h6 bold caps black">Blog Home</a>
      </footer>
    </body>

    <style>

      /* Lazy hacks for bad behaving elements */
      .text-decoration-none:hover {
        background-image: none;
      }

      img {
        max-width: 100%;
      }

      header {
        padding-bottom: 0px !important;
      }
    </style>
</html>


